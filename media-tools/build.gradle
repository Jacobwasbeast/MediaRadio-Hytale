plugins {
    id 'java-library'
}

import groovy.json.JsonSlurper

java {
    toolchain.languageVersion = JavaLanguageVersion.of(java_version)
}

repositories {
    mavenCentral()
}

dependencies {
    def hytaleHome = rootProject.ext.hytaleHome
    def patchline = rootProject.ext.patchline
    implementation(files("$hytaleHome/install/$patchline/package/game/latest/Server/HytaleServer.jar"))
}

tasks.register('downloadEmbeddedTools') {
    group = 'media-tools'
    description = 'Downloads latest yt-dlp and ffmpeg binaries into media-tools resources.'
    doLast {
        def toolsRoot = file('src/main/resources/tools')
        def tmpRoot = file("$buildDir/tmp/embedded-tools")
        tmpRoot.mkdirs()

        def jsonSlurper = new JsonSlurper()

        def readUrl = { String url ->
            def conn = new URL(url).openConnection()
            conn.setRequestProperty('User-Agent', 'MediaRadio-EmbeddedTools')
            conn.setConnectTimeout(30000)
            conn.setReadTimeout(30000)
            conn.getInputStream().getText('UTF-8')
        }

        def downloadFile = { String url, File dest ->
            dest.parentFile.mkdirs()
            def conn = new URL(url).openConnection()
            conn.setRequestProperty('User-Agent', 'MediaRadio-EmbeddedTools')
            conn.setConnectTimeout(30000)
            conn.setReadTimeout(30000)
            conn.getInputStream().withCloseable { input ->
                dest.withOutputStream { out ->
                    out << input
                }
            }
        }

        def urlExists = { String url ->
            try {
                def conn = new URL(url).openConnection()
                conn.setRequestProperty('User-Agent', 'MediaRadio-EmbeddedTools')
                conn.setConnectTimeout(15000)
                conn.setReadTimeout(15000)
                conn.setRequestMethod('HEAD')
                conn.connect()
                return conn.responseCode >= 200 && conn.responseCode < 300
            } catch (Exception ignored) {
                return false
            }
        }

        def sha256 = { File file ->
            def digest = java.security.MessageDigest.getInstance('SHA-256')
            file.withInputStream { stream ->
                byte[] buffer = new byte[8192]
                int read
                while ((read = stream.read(buffer)) > 0) {
                    digest.update(buffer, 0, read)
                }
            }
            return digest.digest().encodeHex().toString()
        }

        def verifySha256 = { File file, String expected ->
            if (!expected) {
                return true
            }
            def actual = sha256(file)
            if (!actual.equalsIgnoreCase(expected)) {
                throw new GradleException("SHA256 mismatch for ${file.name}: expected ${expected}, got ${actual}")
            }
            return true
        }

        def unzipSingle = { File zipFile, String suffix, File outFile ->
            def zip = new java.util.zip.ZipFile(zipFile)
            try {
                def entry = zip.entries().find { it.name.endsWith(suffix) && !it.isDirectory() }
                if (entry == null && suffix.startsWith('/')) {
                    def alt = suffix.substring(1)
                    entry = zip.entries().find { it.name.endsWith(alt) && !it.isDirectory() }
                }
                if (entry == null && suffix == '/ffmpeg') {
                    entry = zip.entries().find {
                        (it.name.endsWith('/ffmpeg/ffmpeg') || it.name.endsWith('\\ffmpeg\\ffmpeg')) && !it.isDirectory()
                    }
                }
                if (entry == null) {
                    throw new GradleException("Missing ${suffix} in ${zipFile.name}")
                }
                outFile.parentFile.mkdirs()
                zip.getInputStream(entry).withCloseable { input ->
                    outFile.withOutputStream { out ->
                        out << input
                    }
                }
            } finally {
                zip.close()
            }
            if (!org.gradle.internal.os.OperatingSystem.current().isWindows()) {
                outFile.setExecutable(true, true)
            }
        }

        println "Downloading latest yt-dlp release..."
        def ytRelease = jsonSlurper.parseText(readUrl('https://api.github.com/repos/yt-dlp/yt-dlp/releases/latest'))
        def ytAssets = ytRelease.assets.collectEntries { [(it.name): it.browser_download_url] }
        def ytChecksumsUrl = ytAssets['SHA2-256SUMS']
        def ytChecksums = [:]
        if (ytChecksumsUrl != null) {
            readUrl(ytChecksumsUrl).eachLine { line ->
                def parts = line.trim().split(/\s+/, 2)
                if (parts.length == 2) {
                    ytChecksums[parts[1]] = parts[0]
                }
            }
        }

        def ytTargets = [
                [name: 'yt-dlp.exe', path: 'windows/x86_64/yt-dlp.exe'],
                [name: 'yt-dlp_arm64.exe', path: 'windows/arm64/yt-dlp_arm64.exe'],
                [name: 'yt-dlp', path: 'linux/x86_64/yt-dlp_linux'],
                [name: 'yt-dlp_linux_aarch64', path: 'linux/arm64/yt-dlp_linux_aarch64'],
                [name: 'yt-dlp_macos', path: 'macos/x86_64/yt-dlp_macos'],
                [name: 'yt-dlp_macos', path: 'macos/arm64/yt-dlp_macos']
        ]

        ytTargets.each { target ->
            def url = ytAssets[target.name]
            if (url == null) {
                println "Skipping ${target.name} (asset not found)"
                return
            }
            def outFile = new File(toolsRoot, target.path)
            def tmpFile = new File(tmpRoot, target.name)
            downloadFile(url, tmpFile)
            verifySha256(tmpFile, ytChecksums[target.name])
            outFile.parentFile.mkdirs()
            outFile.bytes = tmpFile.bytes
            if (!org.gradle.internal.os.OperatingSystem.current().isWindows()) {
                outFile.setExecutable(true, true)
            }
            println "Saved ${target.name} -> ${outFile}"
        }

        println "Downloading latest ffmpeg builds..."
        def ffmpegUrls = [
                [url: 'https://ffmpeg.martin-riedl.de/redirect/latest/macos/amd64/snapshot/ffmpeg.zip', out: 'macos/x86_64/ffmpeg', suffix: '/ffmpeg'],
                [url: 'https://ffmpeg.martin-riedl.de/redirect/latest/macos/arm64/snapshot/ffmpeg.zip', out: 'macos/arm64/ffmpeg', suffix: '/ffmpeg'],
                [url: 'https://ffmpeg.martin-riedl.de/redirect/latest/linux/amd64/snapshot/ffmpeg.zip', out: 'linux/x86_64/ffmpeg', suffix: '/ffmpeg'],
                [url: 'https://ffmpeg.martin-riedl.de/redirect/latest/linux/arm64/snapshot/ffmpeg.zip', out: 'linux/arm64/ffmpeg', suffix: '/ffmpeg']
        ]

        ffmpegUrls.eachWithIndex { entry, idx ->
            def zipFile = new File(tmpRoot, "ffmpeg-riedl-${idx}.zip")
            downloadFile(entry.url, zipFile)
            unzipSingle(zipFile, entry.suffix, new File(toolsRoot, entry.out))
            println "Extracted ${entry.url} -> ${entry.out}"
        }

        def btbnChecksumsUrl = 'https://github.com/BtbN/FFmpeg-Builds/releases/download/latest/checksums.sha256'
        def btbnChecksums = [:]
        readUrl(btbnChecksumsUrl).eachLine { line ->
            def parts = line.trim().split(/\s+/, 2)
            if (parts.length == 2) {
                btbnChecksums[parts[1]] = parts[0]
            }
        }

        def win64 = [name: 'ffmpeg-master-latest-win64-lgpl.zip',
                url: 'https://github.com/BtbN/FFmpeg-Builds/releases/download/latest/ffmpeg-master-latest-win64-lgpl.zip']
        def winarm64 = [name: 'ffmpeg-master-latest-winarm64-lgpl.zip',
                url: 'https://github.com/BtbN/FFmpeg-Builds/releases/download/latest/ffmpeg-master-latest-winarm64-lgpl.zip']

        def extractBtbn = { def asset, String outRel ->
            if (!urlExists(asset.url)) {
                println "Skipping ${outRel} (missing ${asset.name})"
                return
            }
            def zipFile = new File(tmpRoot, asset.name)
            downloadFile(asset.url, zipFile)
            def expected = btbnChecksums[asset.name]
            if (expected != null) {
                verifySha256(zipFile, expected)
            }
            unzipSingle(zipFile, '/bin/ffmpeg.exe', new File(toolsRoot, outRel))
            println "Extracted ${asset.name} -> ${outRel}"
        }

        extractBtbn(win64, 'windows/x86_64/ffmpeg.exe')
        extractBtbn(winarm64, 'windows/arm64/ffmpeg.exe')

        println "Embedded tools download complete."
    }
}

tasks.named('build') {
    dependsOn 'verifyBinaries'
}

tasks.named('assemble') {
    dependsOn 'verifyBinaries'
}

tasks.register('verifyBinaries') {
    group = 'media-tools'
    description = 'Checks embedded binaries exist and look valid without downloading.'
    doLast {
        def toolsRoot = file('src/main/resources/tools')
        def expected = [
                'windows/x86_64/yt-dlp.exe',
                'windows/arm64/yt-dlp_arm64.exe',
                'windows/x86_64/ffmpeg.exe',
                'windows/arm64/ffmpeg.exe',
                'macos/x86_64/yt-dlp_macos',
                'macos/arm64/yt-dlp_macos',
                'macos/x86_64/ffmpeg',
                'macos/arm64/ffmpeg',
                'linux/x86_64/yt-dlp_linux',
                'linux/arm64/yt-dlp_linux_aarch64',
                'linux/x86_64/ffmpeg',
                'linux/arm64/ffmpeg'
        ]

        def warn = { String msg -> println "WARN: ${msg}" }

        expected.each { rel ->
            def fileObj = new File(toolsRoot, rel)
            if (!fileObj.exists()) {
                warn("Missing binary: ${rel}")
                return
            }
            if (fileObj.length() == 0L) {
                warn("Empty binary: ${rel}")
            }
            if (!org.gradle.internal.os.OperatingSystem.current().isWindows()
                    && rel.endsWith('.exe') == false
                    && !fileObj.canExecute()) {
                warn("Binary not executable: ${rel}")
            }
        }
    }
}
